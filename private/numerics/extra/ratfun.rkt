#lang racket/base

;;;; Rational Functions interpolated from procedures.

;;; This file contains:
;;;
;;; (procedure->ratfun <procedure> <degree>) -> <rcf>

;;; The following procedure, takes a procedure that computes a function
;;; of a complex variable of known degree, and returns a rational function.
;;;
;;;                  a2*s^2 + a1*s + a0
;;;              --------------------------
;;;              b3s^3 + b2*s^2 + b1*s + b0
;;;
;;; The degree supplied, n, corresponds to the max degree of the
;;; denominator or (which is the same thing) to 1 + the max degree of
;;; the numerator.  If n is too small, the procedure will return the
;;; rational function that agrees with the values of the given
;;; procedure at 2n test points generated by TEST-POINTS.  If n is too
;;; large, an error is signalled, indicating that the equations are
;;; not independent.  The answer is normalized so that the highest
;;; non-zero power in the denominator has coefficient 1.

;; (provide procedure->ratfun)

;; -----------------------------------------------------------------------------

;; TODO unbound variables
;; From numerics/linear
;; - lu-rank
;; - lu-decompose
;; From kernel/matrices.scm
;; - matrix-by-rows
(require mechanics
         (only-in racket/list dropf))

;; =============================================================================

;; TODO rename this, and figure out what data structure it's making
(define (help lst order)
  (cond
   [(null? lst) '()]
   [(= (car lst) 0)
    (help (cdr lst) (add1 order))]
   [else
    (cons (cons order (car lst)) (help (cdr lst) (add1 order)))]))

(define (procedure->ratfun procedure n)
  (define (list->srcf lst)
    (list '*rcf*
          (list->spcf (car lst))
          (list->spcf (cadr lst))))
  (define (list->spcf lst)
    (cons '*spcf*
          (cons 1 (help lst 0))))
  (when (< n 1) (error "Bad maximum degree -- PROCEDURE->RAT-FUNC" n))
  (define coeffs (rat-fun-vector procedure n))
  (define a-part (build-list n (lambda (i) (vector-ref coeffs i))))
  (define b-part (build-list n (lambda (i) (vector-ref coeffs (+ i n)))))
  (list->srcf (list (reverse (truncate-leading-zeros (reverse a-part)))
                    (append b-part '(1))))) ;b[n]=1

;; -----------------------------------------------------------------------------
;; -- Helpers

(define (truncate-leading-zeros l)
  (dropf l zero?))

;;; We generate the 2n by 2n matrix M of coefficients of the a[i]
;;; and b[i] obtained by evaluating f at 2n points and setting
;;; this equal to the desired rational form.
(define (rat-fun-vector f n)
  (define e (assemble-matrix-equation f n))
  (define A (car e))
  (define B (cadr e))
  ;; TODO rename
  (define (lam lumatrix luperm lusign)
    (define rank (lu-rank lumatrix))
    (if (= rank (* 2 n)) ;ok!
        (lu-backsubstitute lumatrix luperm B)
        (error "N is too large -- PROCEDURE->RAT-FUNC" n)))
  (lu-decompose A lam allow-zero-pivot))

;; Assembles the matrix of coefficients and the drive vector.
;;  The unknowns are in the order a[0], ... a[n-1], b[0], ... b[n-1].
;; The rows are produced by evaluating f at 2n+1 test points.
(define (assemble-matrix-equation f n)
  (define equations (for/list ([i (test-points (* n 2))])
                      (eqn i f n)))
  (list (matrix-by-rows (map cadr equations))
        (list->vector (map car equations))))

;; Test points are generated along a line parallel to the imaginary axis
;; and spaced out to fit within a range near the unit circle.
(define (test-points num)
  (define space (/ test-point-imag (sub1 num)))
  (define (make-imags n)
    (cond [(= n 0) '()]
          [(odd? n) (cons (* n space)    (make-imags (sub1 n)))]
          [else     (cons (* -1 n space) (make-imags (sub1 n)))]))
  (for/list ([imag (make-imags num)])
    (make-rectangular test-point-real imag)))

;; Arbitrary magic numbers
(define test-point-real (/ 1 10))
(define test-point-imag 1.0)

;; Returns a representation of an equation:
;;  x^n*f(x) =
;;     a[0] + ... + x^(n-1)a[n-1] - f(x)*b[0] - ... - x^(n-1)*f(x)*b[n-1]
;; as
;; ( x^n*f(x)  ( 1 ... x^(n-1) -f(x) ... - x^(n-1)*f(x) ) )
(define (eqn x f n)
  (define fx (f x))
  (let lp ([i 0] [xp 1] [acoeffs '()] [bcoeffs '()])
    (if (= i n)
        (list (* fx xp) append (reverse acoeffs) (reverse bcoeffs))
        (lp (add1 i)
            (* xp x)
            (cons xp acoeffs)
            (cons (* -1 xp fx) bcoeffs)))))

;; =============================================================================

(module+ test
  (require rackunit)

)
